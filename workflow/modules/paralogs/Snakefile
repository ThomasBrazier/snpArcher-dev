import pandas as pd
import os
include: "common.smk"


samples = pd.read_table(config["samples"], sep=",", dtype=str).replace(' ', '_', regex=True)
REFGENOME = samples['refGenome'].unique().tolist()


wildcard_constraints:
    prefix=config["final_prefix"]

rule all:
    input:
        target = expand("results/{refGenome}/paralogs/rCNV/{prefix}_rCNV.html", refGenome=REFGENOME, prefix=config["final_prefix"])


# samples = pd.read_table(config["samples"], sep=",", dtype=str).replace(' ', '_', regex=True)
# REFGENOME = samples['refGenome'].unique().tolist()
# _samples = samples.loc[(samples["refGenome"] == REFGENOME)]["BioSample"].unique().tolist()

# wildcard_constraints:
#     prefix=config["final_prefix"]

# rule all:
#     input:
#         expand("results/{refGenome}/paralogs/{sample}_hmm_region.rf", refGenome=REFGENOME, sample=_samples)


# rule calcLR:
#     """
#     ngsParalog is a program for detecting genomic regions that are problematic for short reading mapping using population-level, next generation sequencing (NGS) data.

#     calcLR will calculate a likelihood ratio (LR) of mismapping reads covering each site.
#     """
#     input:
#         bam = "results/{refGenome}/bams/{sample}_final.bam"
#     output:
#         "results/{refGenome}/paralogs/{sample}_calcLR.lr"
#     conda:
#         "envs/paralogs.yml"
#     log:
#         "logs/{refGenome}/calcLR/{sample}.txt"
#     benchmark:
#         "benchmarks/{refGenome}/calcLR/{sample}.txt"
#     shell:
#         """
#         samtools mpileup -b {input.bam} |
#         ngsParalog calcLR -infile - \
#                             -outfile {output} \
#                             -minQ {config[minQ]} \
#                             -minind 1 \
#                             -mincov {config[mincov]}
#         """


# rule HMM_region:
#     input:
#         bam = "results/{refGenome}/bams/{sample}_final.bam",
#         calcLR = "results/{refGenome}/paralogs/{sample}_calcLR.lr"
#     output:
#         "results/{refGenome}/paralogs/{sample}_hmm_region.rf"
#     conda:
#         "envs/paralogs.yml"
#     log:
#         "logs/{refGenome}/HMM_region/{sample}.txt"
#     benchmark:
#         "benchmarks/{refGenome}/HMM_region/{sample}.txt"
#     shell:
#         """
#         dupHMM.R --lrfile={input.calcLR} --outfile="results/{refGenome}/paralogs/{sample}_hmm_region" -n 1
#         """

rule rCNV:
    input:
        vcfFinal = "results/{refGenome}/{prefix}_raw.vcf.gz",
        vcfFinalidx = "results/{refGenome}/{prefix}_raw.vcf.gz.tbi"
    output:
        "results/{refGenome}/paralogs/rCNV/{prefix}_allele_info.tsv",
        "results/{refGenome}/paralogs/rCNV/{prefix}_deviants.tsv",
        "results/{refGenome}/paralogs/rCNV/{prefix}_CNV.tsv",
        "results/{refGenome}/paralogs/rCNV/{prefix}_rCNV.html"
    conda:
        "envs/rcnv.yml"
    log:
        "logs/{refGenome}/rCNV/{prefix}.txt"
    benchmark:
        "benchmarks/{refGenome}/rCNV/{prefix}.txt"
    params:
        refGenome = "{refGenome}",
        prefix = "{prefix}",
        maxMissSample = config['maxMissSample'],
        maxMissSNP = config['maxMissSNP'],
        maxRelatedness = config['maxRelatedness']
    script:
        "scripts/rcnv.R"
#        mkdir -p results/{params.refGenome}/paralogs/rCNV/


# TODO Output BED files


# TODO Annotate the vcf with the probability to be a CNV
# and whether or not the SNP was included in the analysis